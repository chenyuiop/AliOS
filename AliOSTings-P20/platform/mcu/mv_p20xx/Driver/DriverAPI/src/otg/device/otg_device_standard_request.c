/**
 *****************************************************************************
 * @file     device_stor_audio_request.c
 * @author   owen
 * @version  V1.0.0
 * @date     7-September-2015
 * @brief    device audio and mass-storage module driver interface
 *****************************************************************************
 * @attention
 *
 * <h2><center>&copy; COPYRIGHT 2013 MVSilicon </center></h2>
 */

#include <string.h>
#include "type.h"
#include "debug.h"


#include "otg_device_hcd.h"





#include "type.h"
#include "otg_device_standard_request.h"

#define	USB_DAC_FREQ				44100			//USB声卡SPEAKER默认采样率
#define	USB_MIC_FREQ				44100			//USB声卡MIC默认采样率


//USB设备描述符
uint8_t DeviceDescriptor[] =
{
	0x12, 		// bLength
	0x01, 		// bDescriptorType
	0,2,//0x10, 0x01,	// bcdUSB
	0x00, 		// bDeviceClass
	0x00, 		// bDeviceSubClass
	0x00, 		// bDeviceProtocol
	0x40,		// bMaxPacketSize0
	0x00, 0x00, // idVendor
	0x00, 0x00,	// idProduct
	0x00, 0x01, // bcdDevice
	0x01, 		// iManufacturer
	0x02,		// iProduct
	0x03,		// iSerialNumber
	0x01,		// bNumConfigurations
};




#define ConfigDescriptor_Tab(x) 	ConfigDescriptor_##x
#define InterFaceNum_Tab(x) 		InterFaceNum_##x
#define DeviceProductString(x) 		gDeviceProductString_##x

//读卡器
const uint8_t ConfigDescriptor_Tab(READER)[] =
{
//一共1个接口
0x09,0x02,0x20,0x00,0x01,0x01,0x00,0x80,0xFA,

	//mass-storage Interface
	0x09,0x04,0x00,0x00,0x02,0x08,0x06,0x50,0x00,
		0x07,0x05,DEVICE_BULK_IN_EP,0x02, DEVICE_FS_BULK_IN_MPS, 0x00,0x01,
		0x07,0x05,DEVICE_BULK_OUT_EP,0x02,DEVICE_FS_BULK_OUT_MPS,0x00,0x01,
};
const uint8_t InterFaceNum_Tab(READER)[] = {0x00,0x80,0x81,0x82,0x83,0x84};


//声卡
const uint8_t ConfigDescriptor_Tab(AUDIO)[] =
{
		//一共4个接口
		0x09,0x02,0xE2,0x00,0x04,0x01,0x00,0x80,0xFA,

			//audio control Interface
			0x09,0x04,0x00,0x00,0x00,0x01,0x01,0x00,0x00,
				0x0A,0x24,0x01,0x00,0x01,0x4F,0x00,0x02,0x01,0x02,
				0x0C,0x24,0x02,0x01,0x01,0x01,0x00,0x02,0x03,0x00,0x00,0x00,
				0x0A,0x24,0x06,0x02,0x01,0x01,0x01,0x02,0x02,0x00,
				0x09,0x24,0x03,0x03,0x01,0x03,0x00,0x02,0x00,
				0x0C,0x24,0x02,0x04,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x00,
				0x0A,0x24,0x06,0x05,0x04,0x01,0x01,0x02,0x02,0x00,
				0x07,0x24,0x05,0x06,0x01,0x05,0x00,
				0x09,0x24,0x03,0x07,0x01,0x01,0x00,0x06,0x00,

			//audio stream Interface, speeaker
			0x09,0x04,0x01,0x00,0x00,0x01,0x02,0x00,0x00,
			0x09,0x04,0x01,0x01,0x01,0x01,0x02,0x00,0x00,
				0x07,0x24,0x01,0x01,0x01,0x01,0x00,
				0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_DAC_FREQ >> 0),(uint8_t)(USB_DAC_FREQ >> 8), 0x00,
				0x09, 0x05, DEVICE_ISO_OUT_EP, 0x09, DEVICE_FS_ISO_OUT_MPS, 0x00, 0x01, 0x00, 0x00,
				0x07,0x25,0x01,0x01,0x00,0x00,0x00,

			//audio stream Interface, microphone
			0x09,0x04,0x02,0x00,0x00,0x01,0x02,0x00,0x00,
			0x09,0x04,0x02,0x01,0x01,0x01,0x02,0x00,0x00,
				0x07,0x24,0x01,0x07,0x01,0x01,0x00,
				0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_MIC_FREQ >> 0), (uint8_t)(USB_MIC_FREQ >> 8), 0x00,
				0x09, 0x05, DEVICE_ISO_IN_EP, 0x09, DEVICE_FS_ISO_IN_MPS, 0x00, 0x01, 0x00, 0x00,
				0x07,0x25,0x01,0x01,0x00,0x00,0x00,

			//HID interface Descriptor 用于声卡控制
			0x09,0x04,0x03,0x00,0x01,0x03,0x00,0x00,0x00,
				0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x21,0x00,
				0x07,0x05,DEVICE_INT_IN_EP,0x03,DEVICE_FS_INT_IN_MPS,0x00,0x01
//
//
////一共4个接口
//0x09,0x02,0xE2,0x00,0x04,0x01,0x00,0x80,0xFA,
//
//	//audio control Interface
//	0x09,0x04,0x00,0x00,0x00,0x01,0x01,0x00,0x00,
//		0x0A,0x24,0x01,0x00,0x01,0x4F,0x00,0x02,0x01,0x02,
//		0x0C,0x24,0x02,0x01,0x01,0x01,0x00,0x02,0x03,0x00,0x00,0x00,
//		0x0A,0x24,0x06,0x02,0x01,0x01,0x01,0x02,0x02,0x00,
//		0x09,0x24,0x03,0x03,0x01,0x03,0x00,0x02,0x00,
//		0x0C,0x24,0x02,0x04,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x00,
//		0x0A,0x24,0x06,0x05,0x04,0x01,0x01,0x02,0x02,0x00,
//		0x07,0x24,0x05,0x06,0x01,0x05,0x00,
//		0x09,0x24,0x03,0x07,0x01,0x01,0x00,0x06,0x00,
//
//	//audio stream Interface, speeaker
//	0x09,0x04,0x01,0x00,0x00,0x01,0x02,0x00,0x00,
//	0x09,0x04,0x01,0x01,0x01,0x01,0x02,0x00,0x00,
//		0x07,0x24,0x01,0x01,0x01,0x01,0x00,
//		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_DAC_FREQ >> 0),(uint8_t)(USB_DAC_FREQ >> 8), 0x00,
//		0x09, 0x05, DEVICE_ISO_OUT_EP, 0x09, DEVICE_FS_ISO_OUT_MPS, 0x00, 0x01, 0x00, 0x00,
//		0x07,0x25,0x01,0x01,0x00,0x00,0x00,
//
//	//audio stream Interface, microphone
//	0x09,0x04,0x02,0x00,0x00,0x01,0x02,0x00,0x00,
//	0x09,0x04,0x02,0x01,0x01,0x01,0x02,0x00,0x00,
//		0x07,0x24,0x01,0x07,0x01,0x01,0x00,
//		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_MIC_FREQ >> 0), (uint8_t)(USB_MIC_FREQ >> 8), 0x00,
//		0x09, 0x05, DEVICE_ISO_IN_EP, 0x09, DEVICE_FS_ISO_IN_MPS, 0x00, 0x01, 0x00, 0x00,
//		0x07,0x25,0x01,0x01,0x00,0x00,0x00,
//
//	//HID interface Descriptor 用于声卡控制
//	0x09,0x04,0x03,0x00,0x01,0x03,0x00,0x00,0x00,
//		0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x21,0x00,
//		0x07,0x05,DEVICE_INT_IN_EP,0x03,DEVICE_FS_INT_IN_MPS,0x00,0x01
};
const uint8_t InterFaceNum_Tab(AUDIO)[] = {0x80,0x00,0x01,0x02,0x03,0x81};


//HID数据传输
const uint8_t ConfigDescriptor_Tab(HID)[] =
{
//一共1个接口
0x09, 0x02, 0x1B, 0x00, 0x01, 0x01, 0x00, 0x80, 0xFA,

	//HID自定数据传输接口
	0x09,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,
	0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x16,0x00
};
const uint8_t InterFaceNum_Tab(HID)[] = {0x80,0x81,0x82,0x83,0x84,0x00};


//读卡器 & 声卡
const uint8_t ConfigDescriptor_Tab(READER_ADUIO)[] =
{
//一共5个接口
0x09,0x02,0xF9,0x00,0x05,0x01,0x00,0x80,0xFA,

	//mass-storage Interface
	0x09,0x04,0x00,0x00,0x02,0x08,0x06,0x50,0x00,
		0x07,0x05,DEVICE_BULK_IN_EP,0x02, DEVICE_FS_BULK_IN_MPS, 0x00,0x01,
		0x07,0x05,DEVICE_BULK_OUT_EP,0x02,DEVICE_FS_BULK_OUT_MPS,0x00,0x01,

	//audio control Interface
	0x09,0x04,0x01,0x00,0x00,0x01,0x01,0x00,0x00,
		0x0A,0x24,0x01,0x00,0x01,0x4F,0x00,0x02,0x02,0x03,
		0x0C,0x24,0x02,0x01,0x01,0x01,0x00,0x02,0x03,0x00,0x00,0x00,
		0x0A,0x24,0x06,0x02,0x01,0x01,0x01,0x02,0x02,0x00,
		0x09,0x24,0x03,0x03,0x01,0x03,0x00,0x02,0x00,
		0x0C,0x24,0x02,0x04,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x00,
		0x0A,0x24,0x06,0x05,0x04,0x01,0x01,0x02,0x02,0x00,
		0x07,0x24,0x05,0x06,0x01,0x05,0x00,
		0x09,0x24,0x03,0x07,0x01,0x01,0x00,0x06,0x00,

	//audio stream Interface, speeaker
	0x09,0x04,0x02,0x00,0x00,0x01,0x02,0x00,0x00,
	0x09,0x04,0x02,0x01,0x01,0x01,0x02,0x00,0x00,
		0x07,0x24,0x01,0x01,0x01,0x01,0x00,
		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_DAC_FREQ >> 0),(uint8_t)(USB_DAC_FREQ >> 8), 0x00,
		0x09, 0x05, DEVICE_ISO_OUT_EP, 0x09, DEVICE_FS_ISO_OUT_MPS, 0x00, 0x01, 0x00, 0x00,
		0x07,0x25,0x01,0x01,0x00,0x00,0x00,

	//audio stream Interface, microphone
	0x09,0x04,0x03,0x00,0x00,0x01,0x02,0x00,0x00,
	0x09,0x04,0x03,0x01,0x01,0x01,0x02,0x00,0x00,
		0x07,0x24,0x01,0x07,0x01,0x01,0x00,
		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_MIC_FREQ >> 0), (uint8_t)(USB_MIC_FREQ >> 8), 0x00,
		0x09, 0x05, DEVICE_ISO_IN_EP, 0x09, DEVICE_FS_ISO_IN_MPS, 0x00, 0x01, 0x00, 0x00,
		0x07,0x25,0x01,0x01,0x00,0x00,0x00,

	//HID interface Descriptor 用于声卡控制
	0x09,0x04,0x04,0x00,0x01,0x03,0x00,0x00,0x00,
		0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x21,0x00,
		0x07,0x05,DEVICE_INT_IN_EP,0x03,DEVICE_FS_INT_IN_MPS,0x00,0x01
};
const uint8_t InterFaceNum_Tab(READER_ADUIO)[] = {0x00,0x01,0x02,0x03,0x04,0x80};


//读卡器 & HID数据传输
const uint8_t ConfigDescriptor_Tab(READER_HID)[] =
{
//一共2个接口
0x09,0x02,0x32,0x00,0x02,0x01,0x00,0x80,0xFA,

	//mass-storage Interface
	0x09,0x04,0x00,0x00,0x02,0x08,0x06,0x50,0x00,
		0x07,0x05,DEVICE_BULK_IN_EP,0x02, DEVICE_FS_BULK_IN_MPS, 0x00,0x01,
		0x07,0x05,DEVICE_BULK_OUT_EP,0x02,DEVICE_FS_BULK_OUT_MPS,0x00,0x01,

	//HID自定数据传输接口
	0x09,0x04,0x01,0x00,0x00,0x03,0x00,0x00,0x00,
		0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x16,0x00
};
const uint8_t InterFaceNum_Tab(READER_HID)[] = {0x00,0x80,0x81,0x82,0x83,0x01};



//声卡 & HID数据传输
const uint8_t ConfigDescriptor_Tab(AUDIO_HID)[] =
{
//一共5个接口
0x09,0x02,0xF4,0x00,0x05,0x01,0x00,0x80,0xFA,

	//audio control Interface
	0x09,0x04,0x00,0x00,0x00,0x01,0x01,0x00,0x00,
		0x0A,0x24,0x01,0x00,0x01,0x4F,0x00,0x02,0x01,0x02,
		0x0C,0x24,0x02,0x01,0x01,0x01,0x00,0x02,0x03,0x00,0x00,0x00,
		0x0A,0x24,0x06,0x02,0x01,0x01,0x01,0x02,0x02,0x00,
		0x09,0x24,0x03,0x03,0x01,0x03,0x00,0x02,0x00,
		0x0C,0x24,0x02,0x04,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x00,
		0x0A,0x24,0x06,0x05,0x04,0x01,0x01,0x02,0x02,0x00,
		0x07,0x24,0x05,0x06,0x01,0x05,0x00,0x09,0x24,0x03,
		0x07,0x01,0x01,0x00,0x06,0x00,

	//audio stream Interface, speeaker
	0x09,0x04,0x01,0x00,0x00,0x01,0x02,0x00,0x00,
	0x09,0x04,0x01,0x01,0x01,0x01,0x02,0x00,0x00,
		0x07,0x24,0x01,0x01,0x01,0x01,0x00,
		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_DAC_FREQ >> 0),(uint8_t)(USB_DAC_FREQ >> 8), 0x00,
		0x09, 0x05, DEVICE_ISO_OUT_EP, 0x09, DEVICE_FS_ISO_OUT_MPS, 0x00, 0x01, 0x00, 0x00,
		0x07,0x25,0x01,0x01,0x00,0x00,0x00,

	//audio stream Interface, microphone
	0x09,0x04,0x02,0x00,0x00,0x01,0x02,0x00,0x00,
	0x09,0x04,0x02,0x01,0x01,0x01,0x02,0x00,0x00,
		0x07,0x24,0x01,0x07,0x01,0x01,0x00,
		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_MIC_FREQ >> 0), (uint8_t)(USB_MIC_FREQ >> 8), 0x00,
		0x09, 0x05, DEVICE_ISO_IN_EP, 0x09, DEVICE_FS_ISO_IN_MPS, 0x00, 0x01, 0x00, 0x00,
		0x07,0x25,0x01,0x01,0x00,0x00,0x00,

	//HID interface Descriptor 用于声卡控制
	0x09,0x04,0x03,0x00,0x01,0x03,0x00,0x00,0x00,
		0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x21,0x00,
		0x07,0x05,DEVICE_INT_IN_EP,0x03,DEVICE_FS_INT_IN_MPS,0x00,0x01,

	//HID自定数据传输接口
	0x09,0x04,0x04,0x00,0x00,0x03,0x00,0x00,0x00,
		0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x16,0x00,
};
const uint8_t InterFaceNum_Tab(AUDIO_HID)[] = {0x80,0x00,0x01,0x02,0x03,0x04};




//读卡器 & 声卡& HID数据传输
const uint8_t ConfigDescriptor_Tab(READER_AUDIO_HID)[] =
{
//一共6个接口
0x09,0x02,0x0B,0x01,0x06,0x01,0x00,0x80,0xFA,

	//mass-storage Interface
	0x09,0x04,0x00,0x00,0x02,0x08,0x06,0x50,0x00,
		0x07,0x05,DEVICE_BULK_IN_EP,0x02, DEVICE_FS_BULK_IN_MPS, 0x00,0x01,
		0x07,0x05,DEVICE_BULK_OUT_EP,0x02,DEVICE_FS_BULK_OUT_MPS,0x00,0x01,

	//audio control Interface
	0x09,0x04,0x01,0x00,0x00,0x01,0x01,0x00,0x00,
		0x0A,0x24,0x01,0x00,0x01,0x4F,0x00,0x02,0x02,0x03,
		0x0C,0x24,0x02,0x01,0x01,0x01,0x00,0x02,0x03,0x00,0x00,0x00,
		0x0A,0x24,0x06,0x02,0x01,0x01,0x01,0x02,0x02,0x00,
		0x09,0x24,0x03,0x03,0x01,0x03,0x00,0x02,0x00,
		0x0C,0x24,0x02,0x04,0x01,0x02,0x00,0x02,0x03,0x00,0x00,0x00,
		0x0A,0x24,0x06,0x05,0x04,0x01,0x01,0x02,0x02,0x00,
		0x07,0x24,0x05,0x06,0x01,0x05,0x00,
		0x09,0x24,0x03,0x07,0x01,0x01,0x00,0x06,0x00,

	//audio stream Interface, speeaker
	0x09,0x04,0x02,0x00,0x00,0x01,0x02,0x00,0x00,
	0x09,0x04,0x02,0x01,0x01,0x01,0x02,0x00,0x00,
		0x07,0x24,0x01,0x01,0x01,0x01,0x00,
		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_DAC_FREQ >> 0),(uint8_t)(USB_DAC_FREQ >> 8), 0x00,
		0x09, 0x05, DEVICE_ISO_OUT_EP, 0x09, DEVICE_FS_ISO_OUT_MPS, 0x00, 0x01, 0x00, 0x00,
		0x07,0x25,0x01,0x01,0x00,0x00,0x00,

	//audio stream Interface, microphone
	0x09,0x04,0x03,0x00,0x00,0x01,0x02,0x00,0x00,
	0x09,0x04,0x03,0x01,0x01,0x01,0x02,0x00,0x00,
		0x07,0x24,0x01,0x07,0x01,0x01,0x00,
		0x0B,0x24,0x02,0x01,0x02,0x02,0x10,0x01,(uint8_t)(USB_MIC_FREQ >> 0), (uint8_t)(USB_MIC_FREQ >> 8), 0x00,
		0x09, 0x05, DEVICE_ISO_IN_EP, 0x09, DEVICE_FS_ISO_IN_MPS, 0x00, 0x01, 0x00, 0x00,
		0x07,0x25,0x01,0x01,0x00,0x00,0x00,

	//HID interface Descriptor 用于声卡控制
	0x09,0x04,0x04,0x00,0x01,0x03,0x00,0x00,0x00,
		0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x21,0x00,
		0x07,0x05,DEVICE_INT_IN_EP,0x03,DEVICE_FS_INT_IN_MPS,0x00,0x01,

	//HID自定数据传输接口
	0x09,0x04,0x05,0x00,0x00,0x03,0x00,0x00,0x00,
		0x09,0x21,0x01,0x02,0x00,0x01,0x22,0x16,0x00
};
const uint8_t InterFaceNum_Tab(READER_AUDIO_HID)[] = {0x00,0x01,0x02,0x03,0x04,0X05};




const uint8_t HidDataReportDescriptor[] =
{
	0x06, 0x00, 0xFF,//Usage Page (Vendor-defined 0xFF00)
	0x09, 0x01, 	//Usage (Vendor-defined 0x0001)
	0xA1, 0xFF,		//Collection (Application)a1 01
		0x19, 0x01,
		0x29, 0x40,
		0x15, 0x00,	//Logical minimum (0)
		0x25, 0xFF,	//Logical maximum (255)
		0x75, 0x08,	//Report Size (8)
		0x95, 0x40,	//Report Count (64)

		0x91, 0x02,	//Output (Data,Value,Absolute,Non-volatile,Bit Field)
	0xC0			// End Collection
};


const uint8_t AudioCtrlReportDescriptor[] =
{
	0x05, 0x0C,		//Usage Page (Consumer)
	0x09, 0x01, 	//Usage (Consumer Control)
	0xA1, 0x01,		//Collection (Application)
		0x15, 0x00,	//Logical minimum (0)
		0x25, 0x01,	//Logical maximum (1)

		0x09, 0xE9,	//VOL+
		0x09, 0xEA, //VOL-
		0x09, 0xB5, //Scan Next Track
		0x09, 0xB6, //Scan Previous Track
		0x09, 0xE2, //Mute
		0x09, 0xB3, //Fast Forward OOC 15.7
		0x09, 0xCD, //Play/Pause
		0x09, 0xB7, //Stop

		0x75, 0x01,	//Report Size (1)
		0x95, 0x08, //Report Count (8)
		0x81, 0x42,
	0xC0
};


uint8_t *gDeviceProductStringTab[7] =
{
	"USB CARD READER",
	"USB AUDIO",
	"USB HID",
	"USB AUDIO & CARD READER",
	"USB CARD READER & HID",
	"USB AUDIO & HID",
	"USB AUDIO & CARD READER & HID"
};


const uint16_t gDeviceVIDTab[7] = {9,8,8,8,8,0,8};
const uint16_t gDevicePIDTab[7] = {1,2,3,4,5,6,7};

//
const uint8_t *ConfigDescriptorTab[7] =
{
	ConfigDescriptor_Tab(READER),
	ConfigDescriptor_Tab(AUDIO),
	ConfigDescriptor_Tab(HID),
	ConfigDescriptor_Tab(READER_ADUIO),
	ConfigDescriptor_Tab(READER_HID),
	ConfigDescriptor_Tab(AUDIO_HID),
	ConfigDescriptor_Tab(READER_AUDIO_HID)
};

const uint8_t *InterFaceNumTab[7] =
{
	InterFaceNum_Tab(READER),
	InterFaceNum_Tab(AUDIO),
	InterFaceNum_Tab(HID),
	InterFaceNum_Tab(READER_ADUIO),
	InterFaceNum_Tab(READER_HID),
	InterFaceNum_Tab(AUDIO_HID),
	InterFaceNum_Tab(READER_AUDIO_HID)
};

extern int kprintf(const char *fmt, ...);
#define	OTG_DBG(format, ...)		printf(format, ##__VA_ARGS__)


uint8_t const DeviceQualifier[10] = {10,6,0x10,0x01,0,0,0,64,1,0};


extern void OTG_DeviceAudioRequest(void);

uint8_t DeviceString_LangID[] = {0x04, 0x03, 0x09, 0x04};

uint8_t Setup[8];
uint8_t Request[64];


uint8_t *ConfigDescriptor;
uint8_t *InterfaceNum;
uint8_t *gDeviceProductString;		//max length: 32bytes
uint8_t *gDeviceString_Manu;		//max length: 32bytes
uint8_t *gDeviceString_SerialNumber;//max length: 32bytes


void OTG_DeviceModeSel(uint8_t Mode)
{
	DeviceDescriptor[8] = gDeviceVIDTab[Mode];
	DeviceDescriptor[9] = gDeviceVIDTab[Mode]>>8;
	DeviceDescriptor[10] = gDevicePIDTab[Mode];
	DeviceDescriptor[11] = gDevicePIDTab[Mode]>>8;
	ConfigDescriptor = (uint8_t *)ConfigDescriptorTab[Mode];
	InterfaceNum = (uint8_t *)InterFaceNumTab[Mode];
	gDeviceProductString = gDeviceProductStringTab[Mode];
	gDeviceString_Manu = "MVSILICON";
	gDeviceString_SerialNumber = "20151012";
}

/**
 * @brief  发送控制传输命令的应答数据
 * @param  Resp 应答数据
 * @param  n 应答数据长度，1 or 2
 * @return NONE
 */
void OTG_DeviceSendResp(uint16_t Resp, uint8_t n)
{
	Resp = CpuToLe16(Resp);
	OTG_DeviceControlSend((uint8_t*)&Resp, n,3);
}

/**
 * @brief  处理获取描述符命令
 * @param  NONE
 * @return NONE
 */
void OTG_DeviceGetDescriptor(void)
{
	uint8_t 	StringBuf[32 * 2 + 2];
	uint8_t*	UsbSendPtr;
	uint16_t	Len;
	switch(Setup[3])
	{
		case USB_DT_DEVICE:
			UsbSendPtr = (uint8_t*)DeviceDescriptor;
			Len = sizeof(DeviceDescriptor);
			break;

		case USB_DT_CONFIG:
			UsbSendPtr = (uint8_t*)ConfigDescriptor;

            Len = UsbSendPtr[3];
            Len = Len<<8;
            Len = Len + UsbSendPtr[2];
			break;

		case USB_DT_STRING:
			if(Setup[2] == 0)			//lang ids
			{
				UsbSendPtr = DeviceString_LangID;
				Len = UsbSendPtr[0];
				break;
			}
			else if(Setup[2] == 1)		//manu
			{
				UsbSendPtr = gDeviceString_Manu;
			}
			else if(Setup[2] == 2)		//product
			{
				UsbSendPtr = gDeviceProductString;
			}
			else 						//serial number
			{
				UsbSendPtr = gDeviceString_SerialNumber;
			}

			for(Len = 0; Len < 32; Len++)
			{
				if(UsbSendPtr[Len] == '\0')
				{
					break;
				}
				StringBuf[2 + Len * 2 + 0] = UsbSendPtr[Len];
				StringBuf[2 + Len * 2 + 1] = 0x00;
			}

			Len = Len * 2 + 2;
			StringBuf[0] = Len;
			StringBuf[1] = 0x03;
			UsbSendPtr = StringBuf;
			break;

		case USB_DT_INTERFACE:
			//PC默认不会发送该命令
			OTG_DBG("USB_DT_INTERFACE\n");
			break;

		case USB_DT_ENDPOINT:
			//PC默认不会发送该命令
			OTG_DBG("USB_DT_ENDPOINT\n");
			break;
			
		case USB_DT_DEVICE_QUALIFIER:
			UsbSendPtr = (uint8_t*)DeviceQualifier;
			Len = 10;
			break;

		case USB_HID_REPORT:
			OTG_DBG("REPORTR\n");
			UsbSendPtr = (uint8_t*)&AudioCtrlReportDescriptor[0];
			Len = sizeof(AudioCtrlReportDescriptor);
//			if(Setup[4] == InterfaceNum[AUDIO_ATL_INTERFACE_NUM])
//			{
//				OTG_DBG("REPORTR\n");
//				UsbSendPtr = (uint8_t*)&AudioCtrlReportDescriptor[0];
//				Len = sizeof(AudioCtrlReportDescriptor);
//			}
//			else if(Setup[4] == InterfaceNum[HID_DATA_INTERFACE_NUM])
//			{
//				OTG_DBG("REPORTR1\n");
//				UsbSendPtr = (uint8_t*)&HidDataReportDescriptor[0];
//				Len = sizeof(HidDataReportDescriptor);
//			}
//			else if(Setup[4] == InterfaceNum[HID_CTL_INTERFACE_NUM])
//			{
//				OTG_DBG("REPORTR1\n");
//				UsbSendPtr = (uint8_t*)&AudioCtrlReportDescriptor[0];
//				Len = sizeof(AudioCtrlReportDescriptor);
//			}
//			else
//			{
//				OTG_DBG("NOT FOUND INTERFACE %d\n",Setup[4]);
//			}
			break;

		default:
			OTG_DBG("UsbDeviceSendStall:100\n");
			OTG_DeviceStallSend(DEVICE_CONTROL_EP);
			return;
	}

	if(Len > Setup[7] * 256 + Setup[6])
	{

		Len = Setup[6];
	}
	OTG_DeviceControlSend(UsbSendPtr, Len,3);
}
#include "gpio.h"
//extern void OTG_DeviceEnableInt(uint8_t EpNum, FPCALLBACK Func);
unsigned int Count = 0;
uint32_t Countccc;
uint8_t Bufferxx[256];
void OnDeviceAudioRcvIsoPacket(void)
{
//	NVIC_DisableIRQ(TMR1_IRQn);
	OTG_DeviceISOReceive(3,Bufferxx,176,&Countccc);
//	NVIC_EnableIRQ(TMR1_IRQn);
//	Count++;
//	if(Count%2)
//	{
//		GPIO_SetRegBits(GPIO_A_OUT,GPIOA0);
//	}
//	else
//	{
//		GPIO_ClrRegBits(GPIO_A_OUT,GPIOA0);
//	}
	OTG_DBG("*");
}

void OTG_DeviceStandardRequest()
{
	uint8_t Resp[8];
	switch(Setup[1])
	{
		case USB_REQ_GET_STATUS:
			OTG_DBG("GetStatus\n");
			//用于获取USB设备接口端点的状态
			Resp[0] = 0x00;
			Resp[1] = 0x00;
			OTG_DeviceControlSend((uint8_t*)&Resp,2,10);
			break;

		case USB_REQ_CLEAR_FEATURE:
			OTG_DBG("ClearFeature\n");
			//用于清除或者禁止USB设备00,接口01,端点02,的某些特性，无数据传输
			break;

		case USB_REQ_SET_FEATURE:
			OTG_DBG("SetFeature\n");
			//用于设置或者使USB设备00,接口01,端点02,的某些特性，无数据传输
			OTG_DeviceStallSend(Setup[4]);
			break;

		case USB_REQ_SET_ADDRESS:
			OTG_DBG("SetAddress\n");
			OTG_DeviceAddressSet(Setup[2] & 0x7F);
			GPIO_RegBitsClear(GPIO_A_IE,GPIOA0);
			GPIO_RegBitsSet(GPIO_A_OE,GPIOA0);
			break;

		case USB_REQ_GET_DESCRIPTOR:
			OTG_DBG("GetDescriptor\n");
			OTG_DeviceGetDescriptor();
			break;
		
		case USB_REQ_SET_DESCRIPTOR:
			OTG_DBG("GetDescriptor\n");
			//DeviceGetDescriptor();
			break;

		case USB_REQ_GET_CONFIGURATION:
			OTG_DBG("GetConfiguration\n");
			Resp[0] = 0x01;
			//OtgDeviceControlSend(Resp, 1,3);
			OTG_DeviceControlSend((uint8_t*)&Resp, 1,3);
			break;

		case USB_REQ_SET_CONFIGURATION:
			OTG_DeviceEndpointReset(DEVICE_BULK_OUT_EP,TYPE_BULK_OUT);
			OTG_DeviceEndpointReset(DEVICE_BULK_IN_EP,TYPE_BULK_IN);
//			OTG_DeviceResetEndpoint(0x81,TYPE_INT_IN);
//			OTG_DeviceResetEndpoint(DEVICE_ISO_IN_EP,TYPE_ISO_IN);
//			OTG_DeviceResetEndpoint(DEVICE_ISO_OUT_EP,TYPE_ISO_OUT);
//
////			UsbDeviceEnableInt(DEVICE_ISO_IN_EP, OnDeviceAudioSendIsoPacket);
//			OTG_DeviceEnableInt(DEVICE_ISO_OUT_EP, OnDeviceAudioRcvIsoPacket);
////			UsbDeviceIsoSend(0, 0,3);
//			//UsbDeviceIsoSend(NULL, 0);
//			NVIC_EnableIRQ(OTG_IRQn);
			break;

		case USB_REQ_GET_INTERFACE:
			OTG_DBG("GetInterface\n");
			Resp[0] = 0x00;
//			UsbDeviceControlSend(Resp, 1,3);
			OTG_DeviceControlSend((uint8_t*)&Resp, 1,3);
			break;

		case USB_REQ_SET_INTERFACE:
			OTG_DBG("SetInterface\n");
			if((Setup[4] == 0x02) && (Setup[2] == 0x01))
			{
				//OTG_DeviceIsoSend(0, 96);
			}
			break;

		case USB_REQ_SYNCH_FRAME:
			OTG_DBG("SYNC FRAME\n");
			break;

		default:
			OTG_DBG("UsbDeviceSendStall 006\n");
			OTG_DeviceStallSend(DEVICE_CONTROL_EP);
			break;
	}
}


//设备类请求
void OTG_DeviceClassRequest()
{
	//CLASS 根据接口来区分命令,每个接口下可能有多个命令，也有可能没有命令，根据实际该类的协议而定
	if(Setup[4] == InterfaceNum[MSC_INTERFACE_NUM])
	{
		OTG_DBG("MAX\n");
		OTG_DeviceSendResp(0x0000, 1);
	}
	else if(Setup[4] == InterfaceNum[AUDIO_ATL_INTERFACE_NUM])
	{
		OTG_DeviceAudioRequest();
	}
	else if(Setup[4] == InterfaceNum[AUDIO_SRM_OUT_INTERFACE_NUM])
	{
		
	}
	else if(Setup[4] == InterfaceNum[AUDIO_SRM_IN_INTERFACE_NUM])
	{
		
	}
	else if(Setup[4] == InterfaceNum[HID_CTL_INTERFACE_NUM])
	{
		
	}
	else if(Setup[4] == InterfaceNum[HID_DATA_INTERFACE_NUM])
	{
		
	}
	else
	{
		
	}
}


//厂商自定义数据处理。
void OTG_DeviceManufacturerRequest()
{
	//厂商自定义数据处理。
}


//未知命令
void OTG_DeviceOtherRequest()
{
	OTG_DBG("UsbDeviceSendStall\n");
	OTG_DeviceStallSend(DEVICE_CONTROL_EP);
}


/**
 * @brief  处理PC发来的控制命令
 * @param  NONE
 * @return NONE
 */
void OTG_DeviceRequestProcess(void)
{
	uint8_t BusEvent = OTG_DeviceBusEventGet();
	uint32_t DataLeng;
	//OTG_DBG("0\n");
	if(BusEvent & 0x04)
	{
		OTG_DeviceAddressSet(0);
	}
	//OTG_DBG("1\n");
	if(OTG_DeviceSetupReceive(Setup, 8, &DataLeng) != DEVICE_NONE_ERR)
	{
		return;
	}
	//OTG_DBG("SETUP\n");
	//判断方向
	//如果是out 需要尽快接受数据,然后处理数据
	//如果是in，需要先准备数据，然后发送数据
	if((Setup[0]&0x80) == 0)//out
	{
		//判断数据长度是否有效。
		if((Setup[6] != 0) || (Setup[7] != 0))
		{
			OTG_DeviceControlReceive(Request,64,&DataLeng,3);
		}
	}
	switch(Setup[0]&0x60)
	{
		case 0x00:
			//标准请求
			OTG_DeviceStandardRequest();
			break;

		case 0x20:
			//类请求
			OTG_DeviceClassRequest();
			break;

		case 0x40:
			//厂商请求
			OTG_DeviceManufacturerRequest();
			break;

		case 0x60:
			//其他请求
			OTG_DeviceOtherRequest();
			break;			
	}

}

